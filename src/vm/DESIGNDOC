       	       	    +---------------------------+
                    |           CS 124          |
                    | PROJECT 5: VIRTUAL MEMORY |
                    |      DESIGN DOCUMENT      |
                    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Alex Ryan <alexryan@caltech.edu>
Jaden Geller <jgeller@caltech.edu>

>> Specify how many late tokens you are using on this assignment: 5

>> What is the Git repository and commit hash for your submission?
   (You only need to include the commit-hash in the file you submit
   on Moodle.)

   Repository URL:  https://github.com/ialexryan/CS124-Project
   commit ...

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.

---- LOGISTICS ----

These questions will help us to keep track of the difficulty level of
assignments, as well as keeping track of which team members worked on
which parts.

>> L1: How many hours did each team member spend on this assignment?
   Make sure that each member's total time is listed.

>> L2: What did each team member focus on for this assignment?  Keep
   descriptions to 25-30 words or less.

Jaden implemented the supplemental page table and automatic stack extension.
Additionally, Jaden designed the page_info data structure and wrote the mmap
functions along with the code that lazily loads files and evicts them to disk.

Note that this design document is a bit long.  Most of the questions can be
answered pretty briefly.  Don't feel a need to write a long answer if it is
not required by the question.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

// `frametable` is a malloc'ed region of memory big enough to hold
// as many frame_info structs as there are frames in physical memory.
// Note that the frametable only contains info about the pages that are
// currently in physical memory, not pages that have been swapped out.
// Here, the frames are ordered exactly the same as they are laid out
// in physical memory.
struct frame_info *frametable;

// frame_eviction_queue represents an ordering of the frames that is
// unrelated to their ordering in physical memory. It will be used for
// a second chance eviction algorithm.
struct list frame_eviction_queue;

// Each instance of this struct stores metadata about one physical frame
struct frame_info {
    bool is_user_page;
    bool is_pinned;
    void* user_vaddr;
    struct list_elem eviction_queue_list_elem;
};


// Supplementary page info associated with a page telling us
// how to initialize, load, and evict it.
struct page_info {
    // The user virtual address at which the page is mapped. Used
    // as the key in the hash map.
    void *virtual_address;
    
    // The element in the thread's hash map.
    struct hash_elem hash_elem;
    
    // The current state of the page in memory.
    enum {
        // Uninitialized means it has never before
        // been loaded. On load, it should use the specified
        // `initialization_method`.
        UNINITIALIZED_STATE,
        
        // Evicted means it has already been loaded and later
        // evicted. Use the specified `restoration_method` to
        // load the page.
        EVICTED_STATE,
        
        // Loaded means it is currently loaded. On eviction,
        // it should use the method compatible with the page's
        // `restoration_method`.
        LOADED_STATE
    } state : 2;

    // The method by which the page should be loaded on first load.
    enum {
        // Load the page such that all memory is set to 0.
        ZERO_INITIALIZATION,
        
        // Load the page using the specified `file_info`.
        FILE_INITIALIZATION
    } initialization_method : 1;
    
    // The method by which the page should be restorated
    // after eviction. A compatible method should be used
    // for eviction as well.
    enum {
        // Restore the page by reading it from swap.
        SWAP_RESTORATION,
        
        // Restore the page by reading its data from file as
        // specified in `file_info`. Note that a page with this
        // restoration method will evict by writing to file unless
        // the page has not been dirtied.
        FILE_RESTORATION
    } restoration_method : 1;
    
    // Whether or not the page supports writes. If that page
    // does not support writes, the eviction method for a page
    // with the `FILE_RESTORATION` restoration method should be
    // to completely toss the data.
    bool writable;
    
    // The data that's used to load the page, either for
    // initialization or after eviction.
    union {
        // If the restoration method is `SWAP_RESTORATION` and
        // the state is `EVICTED_STATE`, this stores the info
        // necessary to load the page back from swap. Otherwise,
        // this contains junk and it is illegal to modify it.
        struct {
            int swap_index;
        } swap_info;
        
        // If the restoration method is `FILE_RESTORATION` and
        // the state is `EVICTED_STATE`, or if the initialization
        // method is FILE_INITIALIZATION and the state is
        // `UNINITIALIZED_STATE`, this stores the info
        // necessary to load the page from file. Otherwise,
        // this contains junk and it is illegal to modify it.
        struct {
            // The file that the page corresponds to.
            struct file *file;
            
            // The offset into the file at which the page begins.
            off_t offset;
            
            // The number of bytes from the file that should be
            // mapped to the page.
            uint32_t num_bytes;
            
            // The next page that is assocated with this file.
            // Utilized for unmapping entire files from a
            // reference to the first page of the file.
            struct page_info *next;
        } file_info;
    };
};

struct thread {
    // Supplemental page table, keyed by virtual page address.
    // Note that it is illegal to access this structure on the initial thread.
    struct hash pagetable;
    ...
};

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.
Our procedure for this is very easy, since our frametable is an array.
Given a kernel virtual address that corresponds to a physical address,
we just convert it to a physical address with the vtop() function and
divide the physical address by PGSIZE to figure out which 4096-byte frame
the address refers to. We then return that index in our frametable array.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?
When our eviction algorithm checks or sets the accessed bit, it does so
on both the kernel page and the user page that point to that frame.
We keep a user_vaddr property on our frame_info struct for precisely
this reason.

TODO: ALSO FIX THIS IN page.c (_pagetable_evict_page_to_file)

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?
Our entire function that returns a new frame (including calls to our
eviction selection algorithm) is behind a lock.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?
We chose to use an array for our frametable since we knew it
would never need to be resized, would usually be full, and would
probably only contain a small number of elements (usually 1024).
The array setup also allowed us to very easily locate the frame
that corresponds to a kernel virtual address.
We also have list_elem's on the frame structs to keep track of
the order our eviction algorithm thinks of the frames as being in.

TODO: talk about data structure for supplementary page table?


		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.
We implemented a simple second-chance eviction algorithm. Whenever
a frame is populated by a page it is added to the back of our
frame_eviction_queue list. When we need to evict a page we choose
the front item in that list. Unless it's pinned or has been recently
accessed, in which case we clear the access flag. Either way, we then
send that frame to the back of the eviction queue.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

We considered any access between the user process's `esp` and `PHYS_BASE`
to be a valid stack access. If the access happens to be below `esp`, it is
not necessarily invalid. We will have a 64 byte buffer zone below the stack
pointer such that any access in this zone will also count as extensions of
the stack.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

WE DON'T

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

WE DON'T

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

WE DON'T

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make synchronization
>> easy, but limit parallelism.  On the other hand, using many locks
>> complicates synchronization and raises the possibility for deadlock
>> but allows for high parallelism.  Explain where your design falls
>> along this continuum and why you chose to design it this way.

NO LOCKS

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future years.  Feel free to tell us anything you want - these
questions are just to spur your thoughts.  Also, feel free to be completely
honest if there are issues with the assignment or the course - you won't be
penalized.  We can't fix things until we know about them.  :-)

>> In your opinion, was this assignment, or any of the parts of it, too
>> easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Were there any parts of the assignment that you felt were unnecessarily
>> tedious or pointless?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the instructor and/or TAs to more
>> effectively assist students, either for future quarters or the remaining
>> projects?

>> Any other comments?
